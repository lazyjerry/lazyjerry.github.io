---
applyTo: "**/*.sh"
description: "Copilot 在 Bash 腳本自動產生繁中（台灣）註解、流程與用途說明之規範"
---

# Bash 註解與腳本 Doc 指南（繁中／台灣）

目的：要求 GitHub Copilot 在你完成或修改 **Bash** 腳本後，自動產生高品質的註解與「腳本／函式文件化」內容，以繁體中文（台灣用語）清楚說明用途、輸入、輸出、流程、錯誤碼、例外與副作用。

---

## 通用原則

- 僅允許調整、整理或新增註解。**禁止**更動或新增任何可執行程式碼（指令、流程控制、變數/常數、函式簽章與內容、匯入/相依、trap 與環境設定）。
- 若發現錯誤或疑慮，不得直接修改程式碼；改以 `# FIXME:`、`# BUG:` 或 `# TODO:` 前綴標註問題、影響與建議處置。
- 靜態檢查：預設對應 **ShellCheck**，於註解中標明忽略理由。
- 註解聚焦：**用途、輸入、輸出、流程、錯誤碼、注意事項/副作用、相依**。避免贅詞與中英夾雜。

---

## 檔頭註解（腳本層級）

放在 shebang 與 `set -Eeuo pipefail` 之後，說明此腳本的責任與使用方式。

```bash
# 腳本用途：描述此腳本在系統中的職責與適用情境。
# 使用方式：簡述基本語法與參數組合。需提供 `--help` 範例。
# 相依工具：bash>=5, curl>=8, jq>=1.7（列出必要 CLI 與版本）。
# 權限與安全：是否需 root、會不會寫檔、讀祕密、存取網路。
# 輸入來源：CLI 參數、環境變數、STDIN、設定檔路徑。
# 輸出結果：STDOUT/檔案/JSON 格式，單位與編碼（UTF-8）。
# 退出碼表：0=成功；2=參數錯誤；3=相依工具不足；4=I/O 失敗；10x=外部 API 失敗。
# 主要流程：1) 解析參數 2) 驗證前置條件 3) 執行核心邏輯 4) 輸出與清理。
# 注意事項：網路重試策略、速率限制、時區假設、快取策略。
# 參考：README 或相關 RFC/手冊連結（如 curl(1), jq(1)）。
```

---

## 函式註解（固定欄位順序）

每個函式上方以多行 `#` 註解。欄位固定，缺一不可。

```bash
# 函式：register_user
# 功能說明：建立新使用者並觸發驗證流程。
# 輸入參數：
#   $1 <email> 使用者 Email，需唯一、RFC 5322 簡化驗證。
#   $2 <password> 明文密碼，將於函式內雜湊。
#   $3 <profile_json> JSON 字串，包含暱稱與時區（可選）。
# 輸出結果：STDOUT 回傳新使用者 ID（整數）；不輸出多餘字串。
# 例外/失敗：
#   2=輸入參數不足；11=Email 已存在；12=寄信服務失敗。
# 流程：
#   1. 驗證參數與格式
#   2. 呼叫資料層建立使用者
#   3. 觸發郵件事件並回傳 ID
# 副作用：寫入資料庫；呼叫外部郵件 API；可能寫入日誌。
# 參考：user_repo_create(), send_verify_mail()
register_user() {
  : # 實作
}
```

> 附註：若函式透過回傳碼溝通結果，請在註解中明載完整**錯誤碼表**，避免魔數。

---

## 變數與環境變數註解

- 全域變數需在宣告處標註型別與用途；單位要清楚。
- 環境變數在檔頭或 `load_env()` 集中描述：來源、預設值、合法範圍。

```bash
# 全域：API_TIMEOUT_SEC 整數秒，預設 10，HTTP 請求逾時。
readonly API_TIMEOUT_SEC=10

# 環境：API_BASE_URL 外部 API 端點，必填，例：https://api.example.com
: "${API_BASE_URL:?必須設定 API_BASE_URL}"
```

---

## 區塊與流程註解

- 關鍵邏輯區塊前加單行註解，說明「做什麼 + 為什麼」。
- 涉及風險操作（刪檔、網路重試、併發）需說明決策理由與權衡。

```bash
# 為降低撞檔風險，使用 mktemp 生成唯一暫存檔並於 on_exit 清理
TMP_FILE=$(mktemp)
```

## 問題標記（FIXME/TODO）規範

- 僅用註解標記，不得以修正程式碼取代標記。
- 前綴固定：
  - `# FIXME:` 用於**已知錯誤或高風險**，需儘速修復。
  - `# TODO:` 用於**尚待完成或可改進**事項。
- 內容需含：問題摘要、影響範圍、建議方向或追蹤議題 ID。
- 範例：

```bash
# FIXME: 此處使用未定義變數 "$user_id"；請在參數解析階段驗證並設定預設值
# TODO: 將重試次數提為常數 RETRY_MAX，並更新檔頭退出碼表
```

---

## 錯誤處理與清理（標準樣板）

- 一律定義 `die()`、`on_err()`、`on_exit()` 與 `trap`。
- 將**清理邏輯**集中在 `on_exit`，避免遺漏。

```bash
# 統一錯誤輸出
err() { printf "[ERR] %s\n" "$*" 1>&2; }
log() { printf "[INF] %s\n" "$*"; }
die() { err "$*"; exit 1; }

on_err() { err "發生錯誤，行號：${BASH_LINENO[0]} 指令：${BASH_COMMAND}"; }
on_exit() { [[ -n "${TMP_FILE:-}" && -f "${TMP_FILE}" ]] && rm -f "$TMP_FILE"; }
trap on_err ERR
trap on_exit EXIT
```

> 若需關閉特定 ShellCheck 規則，請以行內註解標明**理由**：`# shellcheck disable=SC2155 # 需在宣告時初始化以保留子殼層 IFS`。

---

## CLI 參數與 `--help` 規範

- 參數解析使用 `getopts` 或 `gnu getopt`（若跨平台，優先 `getopts`）。
- 必備：`-h|--help` 列印**用法 + 參數說明 + 範例 + 退出碼表**。

```bash
usage() {
  cat <<'USAGE'
用法：script.sh [-f <檔案>] [-n <次數>] [--dry-run]
參數：
  -f <檔案>   輸入檔路徑，必填且需存在
  -n <次數>   嘗試次數，整數，預設 3
  --dry-run    僅顯示將執行的步驟，不實際寫入
  -h, --help   顯示本說明

退出碼：
  0 成功
  2 參數錯誤
  3 相依工具不足
  4 I/O 失敗
範例：
  script.sh -f input.txt -n 5
USAGE
}
```

---

## I/O 與副作用約定

- 檔案寫入需說明路徑與覆寫規則；刪除前先 `[[ -e ]]` 防呆。
- 網路呼叫請說明重試策略（次數、退避），並列入退出碼對應。
- 日誌輸出規格固定（時間戳、層級、訊息）。最多一層 `set -x`，禁止在預設路徑洩漏機密。

---

## 禁止事項

- 禁止新增、刪除或改動任何可執行程式碼（指令、流程控制、變數/常數、函式內容、匯入/相依、trap/環境設定）。
- 禁止以直接改碼取代問題標記；發現錯誤或疑慮時須以 `# FIXME:` 或 `# TODO:` 註解記錄。

- 不得留空的欄位（用途/參數/輸出/錯誤碼/流程）。
- 不得以「如上」「略」帶過任何說明。
- 不得未註明理由就忽略 ShellCheck 規則。
- 不得使用未加引號的變數或未處理空白的路徑。

---

## Copilot 產出規則（行為）

- 僅調整、整理或新增註解；**不得**更動任何可執行程式碼。遇錯誤以 `# FIXME:` 或 `# TODO:` 標記。
- 新增或修改函式時，自動補齊上節的**函式註解**欄位。
- 新增腳本時，自動產生**檔頭註解**、`set -Eeuo pipefail`、trap 樣板與 `usage()`。
- 一律使用繁體中文（台灣用語），維持固定欄位順序與錯誤碼表。
- 無法判斷型別或格式時，給出保守假設並明載於註解。

---

## 審查清單（提交前自檢）

- [ ] 僅改動註解，無任何可執行程式碼差異（指令、變數、函式、流程）。
- [ ] 錯誤或疑慮均以 `# FIXME:` 或 `# TODO:` 標記，並描述影響與建議處置。
- [ ] 檔頭註解是否完整列出用途、相依、輸入輸出、退出碼表。
- [ ] 函式註解是否覆蓋參數、輸出、流程、失敗碼、副作用。
- [ ] 是否標註單位、格式、合法值與預設。
- [ ] 是否有 ShellCheck 忽略且附明確理由。
- [ ] 是否描述主要副作用（I/O、網路、時區）。
- [ ] 無空白或無意義註解，無中英夾雜與不當縮寫。

---

## 最小可用樣板（供 Copilot 參考擴充）

```bash
#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

# 腳本用途：示範最小可用樣板
# 使用方式：sample.sh -f <檔案>
# 相依工具：bash>=5
# 權限與安全：不需 root；僅讀取檔案
# 輸入來源：CLI -f；環境變數 SAMPLE_FLAG（可選，0/1）
# 輸出結果：STDOUT 列印處理結果
# 退出碼表：0=成功；2=參數錯誤；4=I/O 失敗
# 主要流程：1) 解析參數 2) 驗證 3) 處理 4) 輸出
# 注意事項：檔案需為 UTF-8

err() { printf "[ERR] %s\n" "$*" 1>&2; }
log() { printf "[INF] %s\n" "$*"; }
die() { err "$*"; exit 1; }

usage() { grep '^# ' "$0" | sed 's/^# //'; }

on_err() { err "行號：${BASH_LINENO[0]} 指令：${BASH_COMMAND}"; }
on_exit() { :; }
trap on_err ERR
trap on_exit EXIT

FILE=""
while getopts ":f:h" opt; do
  case "$opt" in
    f) FILE="$OPTARG" ;;
    h) usage; exit 0 ;;
    *) usage; exit 2 ;;
  esac
done
[[ -n "$FILE" && -f "$FILE" ]] || die "請以 -f 指定存在的檔案"

# 函式：process_file
# 功能說明：逐行讀取並輸出行號與內容
# 輸入參數：
#   $1 <path> 目標檔案路徑，需存在
# 輸出結果：STDOUT 列印 "<行號> <內容>"
# 例外/失敗：4=I/O 失敗
# 流程：1) 讀取檔案 2) 列印行號
# 副作用：無
process_file() {
  local path="$1"
  [[ -f "$path" ]] || return 4
  local i=0
  while IFS= read -r line; do
    ((i++))
    printf "%d %s\n" "$i" "$line"
  done <"$path"
}

process_file "$FILE" || exit 4
```
